<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Editor Web - √âditeur Hybride</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a1a;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }

        .header h1 {
            font-size: 16px;
            font-weight: 600;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ffa500;
        }

        .status-indicator.ready {
            background: #51cf66;
        }

        .buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background: #4c6ef5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #364fc7;
        }

        .main-content {
            display: flex;
            height: calc(100vh - 60px);
        }

        .hybrid-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .pane-header {
            background: #2d2d2d;
            padding: 10px 20px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            font-size: 14px;
        }

        .hybrid-editor-container {
            flex: 1;
            padding: 20px;
        }

        #hybridEditor {
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.8;
            overflow-y: auto;
            outline: none;
        }

        #hybridEditor:focus {
            border-color: #4c6ef5;
        }

        .editor-line {
            min-height: 1.8em;
            padding: 4px 8px;
            margin: 0;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            cursor: text;
        }

        .editor-line.current-line {
            background-color: rgba(76, 110, 245, 0.1);
            border-left: 3px solid #4c6ef5;
            padding-left: 15px;
        }

        .editor-line.rendered-line {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .editor-line:empty::before {
            content: '\200B';
            color: transparent;
        }

        /* Styling for rendered HTML */
        .editor-line h1, .editor-line h2, .editor-line h3, .editor-line h4, .editor-line h5, .editor-line h6 {
            margin: 0;
            color: #fff;
            display: inline;
        }

        .editor-line h1 { font-size: 24px; }
        .editor-line h2 { font-size: 20px; }
        .editor-line h3 { font-size: 18px; }

        .editor-line strong {
            color: #fff;
            font-weight: bold;
        }

        .editor-line em {
            color: #ffd93d;
            font-style: italic;
        }

        .editor-line u {
            text-decoration: underline;
        }

        .editor-line mark {
            background: #ffd93d;
            color: #000;
            padding: 1px 2px;
        }

        .footer {
            background: #2d2d2d;
            padding: 8px 20px;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #888;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>C Editor Web - √âditeur Hybride</h1>
        <div class="status">
            <span class="status-indicator" id="statusIndicator"></span>
            <span id="statusText">Chargement...</span>
        </div>
        <div class="buttons">
            <button class="btn" onclick="exportMarkdown()">üìÑ Export MD</button>
            <button class="btn" onclick="exportJSON()">üìã Export JSON</button>
            <button class="btn" onclick="exportHTML()">üåê Export HTML</button>
        </div>
    </div>

    <div class="main-content">
        <div class="hybrid-editor">
            <div class="pane-header">√âditeur Hybride - Ligne courante en Markdown, autres lignes rendues</div>
            <div class="hybrid-editor-container">
                <div id="hybridEditor" contenteditable="true" spellcheck="false">
                    <div class="editor-line" data-line="0"># Titre</div>
                    <div class="editor-line" data-line="1"></div>
                    <div class="editor-line" data-line="2">√âcrivez votre markdown ici...</div>
                    <div class="editor-line" data-line="3"></div>
                    <div class="editor-line" data-line="4">Exemple:</div>
                    <div class="editor-line" data-line="5">- **Gras**</div>
                    <div class="editor-line" data-line="6">- *Italique*</div>
                    <div class="editor-line" data-line="7">- ==Surlign√©==</div>
                    <div class="editor-line" data-line="8">- ++Soulign√©++</div>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        C Editor Web - Powered by Emscripten WASM | 
        <a href="https://github.com/SorbetUP/c-editor" style="color: #4c6ef5;">GitHub</a>
    </div>

    <script src="editor.js"></script>
    <script>
        let editorModule = null;
        let isWasmReady = false;
        
        const hybridEditor = document.getElementById('hybridEditor');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        let currentLineIndex = -1;
        let editorLines = [];
        let lineContents = [];

        // Initialize WASM module
        async function initializeWasm() {
            try {
                statusText.textContent = 'Chargement WASM...';
                
                // Wait for EditorModule to be available
                let attempts = 0;
                const maxAttempts = 50;
                
                while (typeof EditorModule === 'undefined' && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (typeof EditorModule !== 'undefined') {
                    console.log('EditorModule found, initializing...');
                    editorModule = await EditorModule();
                    isWasmReady = true;
                    statusIndicator.classList.add('ready');
                    statusText.textContent = 'WASM Ready';
                    console.log('WASM module loaded successfully');
                    
                    // Initialize C engine first
                    console.log('üîß Initializing C engine...');
                    try {
                        const initResult = editorModule.ccall('editor_library_init', 'number', [], []);
                        console.log('‚úÖ C ENGINE INIT RESULT:', initResult);
                        
                        // Enable debug logging
                        try {
                            editorModule.ccall('editor_enable_debug_logging', 'void', ['boolean'], [true]);
                            console.log('‚úÖ C ENGINE DEBUG ENABLED');
                        } catch (error) {
                            console.warn('Debug logging not available:', error);
                        }
                        
                        // Test C engine immediately
                        console.log('üß™ Testing C engine...');
                        const testJson = editorModule.ccall('editor_parse_markdown_simple', 'string', ['string'], ['**test**']);
                        console.log('‚úÖ C ENGINE JSON TEST:', testJson);
                        
                        // Test new HTML function
                        const testHtml = editorModule.ccall('editor_markdown_to_html', 'string', ['string'], ['**test**']);
                        console.log('‚úÖ C ENGINE HTML TEST:', testHtml);
                    } catch (error) {
                        console.error('‚ùå C ENGINE TEST FAILED:', error);
                    }
                    
                    // Re-render lines with C engine
                    if (editorLines.length > 0) {
                        editorLines.forEach((line, index) => {
                            if (index !== currentLineIndex) {
                                renderLineAsHTML(index);
                            }
                        });
                    }
                } else {
                    throw new Error('EditorModule not found after ' + maxAttempts + ' attempts');
                }
            } catch (error) {
                console.warn('WASM not available:', error);
                statusIndicator.style.background = '#ff6b6b';
                statusText.textContent = '‚ùå WASM indisponible - Mode JavaScript';
                isWasmReady = false;
            }
        }

        // FALLBACK COMPLETELY REMOVED - ONLY C ENGINE ALLOWED

        // Simple JSON to HTML - using C engine JSON output (NOT JavaScript markdown)
        function jsonToHtmlSimple(jsonStr) {
            try {
                const doc = JSON.parse(jsonStr);
                if (!doc.elements || doc.elements.length === 0) {
                    return '';
                }
                
                let html = '';
                for (const element of doc.elements) {
                    if (element.type === 'text') {
                        let text = element.text || '';
                        
                        // Use spans if available (C engine output)
                        if (element.spans && element.spans.length > 0) {
                            for (const span of element.spans) {
                                let spanText = span.text || '';
                                
                                if (span.bold) spanText = `<strong>${spanText}</strong>`;
                                if (span.italic) spanText = `<em>${spanText}</em>`;
                                if (span.has_underline) spanText = `<u>${spanText}</u>`;
                                if (span.has_highlight) spanText = `<mark>${spanText}</mark>`;
                                
                                html += spanText;
                            }
                        } else {
                            // Apply element-level formatting
                            if (element.bold) text = `<strong>${text}</strong>`;
                            if (element.italic) text = `<em>${text}</em>`;
                            if (element.underline) text = `<u>${text}</u>`;
                            if (element.highlight) text = `<mark>${text}</mark>`;
                            html += text;
                        }
                        
                        // Handle headers
                        if (element.level > 0) {
                            html = `<h${element.level}>${html}</h${element.level}>`;
                        }
                    }
                }
                
                return html;
            } catch (error) {
                console.warn('C ENGINE JSON parsing error:', error);
                return '';
            }
        }

        // Get current cursor line
        function getCurrentLineElement() {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return null;
            
            let node = selection.anchorNode;
            
            // Find the parent .editor-line element
            while (node && node !== hybridEditor) {
                if (node.classList && node.classList.contains('editor-line')) {
                    return node;
                }
                node = node.parentNode;
            }
            
            return null;
        }
        
        // Update line states (current vs rendered)
        function updateLineStates() {
            const currentLine = getCurrentLineElement();
            const newLineIndex = currentLine ? parseInt(currentLine.dataset.line) : -1;
            
            if (newLineIndex === currentLineIndex) return; // No change
            
            console.log('Line changed from', currentLineIndex, 'to', newLineIndex);
            
            // Render the previously current line (if any)
            if (currentLineIndex >= 0 && editorLines[currentLineIndex]) {
                renderLineAsHTML(currentLineIndex);
            }
            
            // Calculate cursor position in the new line BEFORE switching it to markdown
            let targetCursorPosition = 0;
            if (newLineIndex >= 0 && editorLines[newLineIndex]) {
                const newLine = editorLines[newLineIndex];
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    try {
                        const range = selection.getRangeAt(0);
                        if (newLine.contains(range.startContainer) || range.startContainer === newLine) {
                            const htmlPosition = calculatePlainTextPosition(newLine);
                            const markdownContent = lineContents[newLineIndex] || '';
                            targetCursorPosition = mapHtmlPositionToMarkdown(htmlPosition, markdownContent);
                            console.log(`üìç HTML position: ${htmlPosition}, Markdown position: ${targetCursorPosition}`);
                        }
                    } catch (error) {
                        console.warn('Error calculating cursor position:', error);
                    }
                }
            }
            
            // Switch new current line to raw markdown
            currentLineIndex = newLineIndex;
            if (currentLineIndex >= 0 && editorLines[currentLineIndex]) {
                showLineAsMarkdownWithPosition(currentLineIndex, targetCursorPosition);
            }
            
            updateLineClasses();
        }
        
        // Update CSS classes for current/rendered lines
        function updateLineClasses() {
            editorLines.forEach((line, index) => {
                line.classList.remove('current-line', 'rendered-line');
                if (index === currentLineIndex) {
                    line.classList.add('current-line');
                } else {
                    line.classList.add('rendered-line');
                }
            });
        }
        
        // C ENGINE HTML - TRY DIRECT HTML FIRST, FALLBACK TO JSON TEMPORARILY
        function renderSingleLine(line) {
            if (!line.trim()) return '&nbsp;';
            
            // C engine MUST be ready - no fallback
            if (!isWasmReady || !editorModule) {
                console.error('‚ùå C ENGINE NOT READY - CANNOT RENDER');
                throw new Error('C ENGINE NOT READY');
            }
            
            // Try direct HTML function first
            try {
                const html = editorModule.ccall('editor_markdown_to_html', 'string', ['string'], [line]);
                if (html) {
                    console.log(`‚úÖ C ENGINE HTML DIRECT: "${line}" -> "${html}"`);
                    return html;
                }
            } catch (error) {
                console.warn('HTML function failed, trying JSON approach:', error);
            }
            
            // Fallback to JSON approach (still using C engine)
            try {
                const jsonStr = editorModule.ccall('editor_parse_markdown_simple', 'string', ['string'], [line]);
                if (jsonStr) {
                    const html = jsonToHtmlSimple(jsonStr);
                    console.log(`‚úÖ C ENGINE JSON: "${line}" -> "${html}"`);
                    return html;
                }
            } catch (error) {
                console.error('‚ùå C ENGINE COMPLETELY FAILED:', error);
                throw new Error('C ENGINE FAILED');
            }
            
            throw new Error('C ENGINE RETURNED EMPTY');
        }
        
        // Escape HTML characters
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Calculate cursor position in plain text from HTML cursor position
        function calculatePlainTextPosition(htmlElement) {
            try {
                const selection = window.getSelection();
                if (selection.rangeCount === 0) return 0;
                
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(htmlElement);
                preCaretRange.setEnd(range.startContainer, range.startOffset);
                
                // Get the text content up to the cursor position
                const textBeforeCursor = preCaretRange.toString();
                return textBeforeCursor.length;
            } catch (error) {
                console.warn('Error calculating plain text position:', error);
                return 0;
            }
        }
        
        // Map position from rendered HTML text to markdown text position
        function mapHtmlPositionToMarkdown(htmlPosition, markdownText) {
            // Common markdown patterns and their adjustments
            const patterns = [
                // Headers: # Title -> position needs +2 (# + space)
                { regex: /^(#{1,6})\s+/, prefix: true },
                // Bold: **text** -> position in middle needs +2 for **
                { regex: /\*\*(.*?)\*\*/, wrapper: true, chars: 2 },
                // Italic: *text* -> position in middle needs +1 for *
                { regex: /\*([^*]*?)\*/, wrapper: true, chars: 1 },
                // Strikethrough: ~~text~~ -> position in middle needs +2 for ~~
                { regex: /~~(.*?)~~/, wrapper: true, chars: 2 },
                // Highlight: ==text== -> position in middle needs +2 for ==
                { regex: /==(.*?)==/, wrapper: true, chars: 2 },
                // Underline: ++text++ -> position in middle needs +2 for ++
                { regex: /\+\+(.*?)\+\+/, wrapper: true, chars: 2 },
            ];
            
            let adjustedPosition = htmlPosition;
            let currentOffset = 0;
            
            // Handle prefix patterns (like headers)
            for (const pattern of patterns) {
                if (pattern.prefix) {
                    const match = markdownText.match(pattern.regex);
                    if (match) {
                        // For headers, all positions after the prefix need adjustment
                        const prefixLength = match[1].length + 1; // # + space
                        adjustedPosition += prefixLength;
                        console.log(`üìä Header detected: adding ${prefixLength} chars`);
                        break;
                    }
                }
            }
            
            // Handle wrapper patterns (like bold, italic, etc.)
            for (const pattern of patterns) {
                if (pattern.wrapper) {
                    let match;
                    let searchFrom = 0;
                    
                    while ((match = pattern.regex.exec(markdownText)) !== null) {
                        const fullMatch = match[0];
                        const innerText = match[1];
                        const startPos = match.index;
                        const innerStartPos = startPos + pattern.chars;
                        const innerEndPos = innerStartPos + innerText.length;
                        
                        // If cursor is inside this wrapper, add the prefix chars
                        const renderedStart = startPos - currentOffset;
                        const renderedEnd = renderedStart + innerText.length;
                        
                        if (htmlPosition >= renderedStart && htmlPosition <= renderedEnd) {
                            adjustedPosition += pattern.chars;
                            console.log(`üìä Wrapper detected (${fullMatch}): adding ${pattern.chars} chars`);
                            break;
                        }
                        
                        // If cursor is after this wrapper, account for hidden chars
                        if (htmlPosition > renderedEnd) {
                            currentOffset += pattern.chars * 2; // opening + closing
                        }
                        
                        // Prevent infinite loop
                        if (pattern.regex.lastIndex === 0) break;
                    }
                    
                    // Reset regex lastIndex for next pattern
                    pattern.regex.lastIndex = 0;
                }
            }
            
            console.log(`üìç Position mapping: HTML ${htmlPosition} -> Markdown ${adjustedPosition}`);
            return adjustedPosition;
        }
        
        // Show line as raw markdown text with specific cursor position
        function showLineAsMarkdownWithPosition(lineIndex, targetCursorPosition = 0) {
            const line = editorLines[lineIndex];
            if (!line) return;
            
            // Get the stored markdown content
            const markdownContent = lineContents[lineIndex] || '';
            
            // Set as plain text (markdown source)
            line.innerHTML = '';
            line.textContent = markdownContent;
            
            // Ensure line is focusable and editable
            line.setAttribute('contenteditable', 'true');
            
            // Restore cursor position if specified
            if (targetCursorPosition > 0) {
                setTimeout(() => {
                    try {
                        line.focus();
                        
                        const range = document.createRange();
                        const newSelection = window.getSelection();
                        
                        // Ensure we don't exceed the text length
                        const textNode = line.firstChild;
                        if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                            const maxPos = textNode.textContent.length;
                            const safePosition = Math.min(targetCursorPosition, maxPos);
                            
                            range.setStart(textNode, safePosition);
                            range.collapse(true);
                            newSelection.removeAllRanges();
                            newSelection.addRange(range);
                            
                            console.log(`‚úÖ Cursor restored to position ${safePosition} in markdown`);
                        }
                    } catch (error) {
                        console.warn('Error restoring cursor position:', error);
                    }
                }, 10);
            }
            
            console.log(`‚úÖ Line ${lineIndex} switched to markdown: "${markdownContent}"`);
        }
        
        // Show line as raw markdown text (legacy function for compatibility)
        function showLineAsMarkdown(lineIndex) {
            showLineAsMarkdownWithPosition(lineIndex, 0);
        }
        
        // Render line as HTML - C ENGINE ONLY
        function renderLineAsHTML(lineIndex) {
            const line = editorLines[lineIndex];
            if (!line) return;
            
            // ALWAYS update content from current line text when it was in markdown mode
            if (lineIndex === currentLineIndex) {
                lineContents[lineIndex] = line.textContent || '';
                console.log(`üíæ Saved line ${lineIndex} content:`, lineContents[lineIndex]);
            }
            
            const markdownText = lineContents[lineIndex] || '';
            console.log(`üîÑ Rendering line ${lineIndex} as HTML:`, markdownText);
            
            if (!markdownText.trim()) {
                line.innerHTML = '&nbsp;';
                return;
            }
            
            // C ENGINE ONLY - if it fails, we debug and fix the C code
            try {
                const renderedHtml = renderSingleLine(markdownText);
                line.innerHTML = renderedHtml;
                console.log(`‚úÖ Line ${lineIndex} rendered:`, renderedHtml);
            } catch (error) {
                console.error(`‚ùå C ENGINE FAILED for line ${lineIndex}:`, error);
                console.error('‚ùå MUST DEBUG AND FIX C ENGINE');
                line.innerHTML = `<span style="color: red;">‚ùå C ENGINE ERROR</span>`;
            }
        }
        
        // Handle Enter key - create new line
        function handleEnterKey() {
            console.log('üîÑ Enter key pressed');
            
            // Save current line content
            if (currentLineIndex >= 0 && editorLines[currentLineIndex]) {
                lineContents[currentLineIndex] = editorLines[currentLineIndex].textContent || '';
            }
            
            // Create new line element
            const newLine = document.createElement('div');
            newLine.className = 'editor-line';
            newLine.textContent = '';
            
            // Insert after current line
            const currentLine = editorLines[currentLineIndex];
            if (currentLine && currentLine.nextSibling) {
                hybridEditor.insertBefore(newLine, currentLine.nextSibling);
            } else {
                hybridEditor.appendChild(newLine);
            }
            
            // Update arrays
            editorLines.splice(currentLineIndex + 1, 0, newLine);
            lineContents.splice(currentLineIndex + 1, 0, '');
            
            // Update line numbers
            editorLines.forEach((line, index) => {
                line.dataset.line = index;
            });
            
            // Move to new line
            currentLineIndex++;
            updateLineStates();
            
            // Focus new line
            const range = document.createRange();
            const selection = window.getSelection();
            range.setStart(newLine, 0);
            range.collapse(true);
            selection.removeAllRanges();
            selection.addRange(range);
        }
        
        // Check if cursor is at line start
        function isAtLineStart(lineElement) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return true; // Default to true for empty selection
            
            const range = selection.getRangeAt(0);
            const offset = range.startOffset;
            
            // If empty line, cursor is at start
            if (!lineElement.textContent || lineElement.textContent.length === 0) {
                return true;
            }
            
            return offset === 0;
        }
        
        // Check if cursor is at line end
        function isAtLineEnd(lineElement) {
            const selection = window.getSelection();
            if (selection.rangeCount === 0) return true; // Default to true for empty selection
            
            const range = selection.getRangeAt(0);
            const textLength = lineElement.textContent ? lineElement.textContent.length : 0;
            
            // If empty line, cursor is at end
            if (textLength === 0) {
                return true;
            }
            
            return range.startOffset >= textLength;
        }
        
        // Handle backspace at line start (merge with previous line)
        function handleBackspaceAtLineStart(lineIndex) {
            console.log(`üîÑ Backspace at line start: ${lineIndex}`);
            
            if (lineIndex === 0) return; // Can't merge first line
            
            const currentLine = editorLines[lineIndex];
            const previousLine = editorLines[lineIndex - 1];
            
            // Get content of both lines
            const currentContent = lineContents[lineIndex] || currentLine.textContent || '';
            const previousContent = lineContents[lineIndex - 1] || '';
            
            // Merge content
            const mergedContent = previousContent + currentContent;
            
            console.log(`üîó Merging: "${previousContent}" + "${currentContent}" = "${mergedContent}"`);
            
            // Update previous line content
            lineContents[lineIndex - 1] = mergedContent;
            
            // Remove current line
            currentLine.remove();
            editorLines.splice(lineIndex, 1);
            lineContents.splice(lineIndex, 1);
            
            // Re-index remaining lines
            editorLines.forEach((line, index) => {
                line.dataset.line = index;
            });
            
            // Move to previous line and position cursor at merge point
            currentLineIndex = lineIndex - 1;
            const mergeLine = editorLines[currentLineIndex];
            
            // Switch to markdown mode
            showLineAsMarkdown(currentLineIndex);
            updateLineStates();
            
            // Position cursor at merge point
            setTimeout(() => {
                mergeLine.focus();
                const range = document.createRange();
                const selection = window.getSelection();
                range.setStart(mergeLine.firstChild || mergeLine, previousContent.length);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }, 10);
        }
        
        // Handle delete at line end (merge with next line)
        function handleDeleteAtLineEnd(lineIndex) {
            console.log(`üîÑ Delete at line end: ${lineIndex}`);
            
            if (lineIndex >= editorLines.length - 1) return; // Can't merge last line
            
            const currentLine = editorLines[lineIndex];
            const nextLine = editorLines[lineIndex + 1];
            
            // Get content of both lines
            const currentContent = lineContents[lineIndex] || currentLine.textContent || '';
            const nextContent = lineContents[lineIndex + 1] || '';
            
            // Merge content
            const mergedContent = currentContent + nextContent;
            
            console.log(`üîó Merging: "${currentContent}" + "${nextContent}" = "${mergedContent}"`);
            
            // Update current line content
            lineContents[lineIndex] = mergedContent;
            currentLine.textContent = mergedContent;
            
            // Remove next line
            nextLine.remove();
            editorLines.splice(lineIndex + 1, 1);
            lineContents.splice(lineIndex + 1, 1);
            
            // Re-index remaining lines
            editorLines.forEach((line, index) => {
                line.dataset.line = index;
            });
            
            // Position cursor at merge point
            setTimeout(() => {
                currentLine.focus();
                const range = document.createRange();
                const selection = window.getSelection();
                range.setStart(currentLine.firstChild || currentLine, currentContent.length);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);
            }, 10);
        }
        
        // Handle line changes (for other cases)
        function handleLineChange() {
            console.log('üîÑ Line change detected');
            
            // Re-scan editor lines
            const newEditorLines = Array.from(hybridEditor.querySelectorAll('.editor-line'));
            
            if (newEditorLines.length !== editorLines.length) {
                console.log(`üìä Line count changed: ${editorLines.length} -> ${newEditorLines.length}`);
                
                // Update arrays
                editorLines = newEditorLines;
                
                // Re-index lines
                editorLines.forEach((line, index) => {
                    line.dataset.line = index;
                });
                
                // Adjust currentLineIndex if necessary
                if (currentLineIndex >= editorLines.length) {
                    currentLineIndex = editorLines.length - 1;
                }
                
                updateLineStates();
            }
        }
        
        // Initialize hybrid editor
        function initializeHybridEditor() {
            console.log('Initializing hybrid editor...');
            
            // Get all editor lines
            editorLines = Array.from(hybridEditor.querySelectorAll('.editor-line'));
            
            // Initialize line contents array
            editorLines.forEach((line, index) => {
                lineContents[index] = line.textContent || '';
                line.dataset.line = index;
            });
            
            // Set up event listeners
            hybridEditor.addEventListener('click', () => {
                setTimeout(updateLineStates, 10); // Small delay for cursor to settle
            });
            
            hybridEditor.addEventListener('keyup', () => {
                setTimeout(updateLineStates, 10);
            });
            
            hybridEditor.addEventListener('focus', () => {
                setTimeout(updateLineStates, 10);
            });
            
            // Handle keyboard events
            hybridEditor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    handleEnterKey();
                } else if (e.key === 'Backspace') {
                    // Handle backspace specially for line merging
                    const currentLine = getCurrentLineElement();
                    if (currentLine) {
                        const lineIndex = parseInt(currentLine.dataset.line);
                        const currentContent = currentLine.textContent || '';
                        const cursorAtStart = isAtLineStart(currentLine);
                        
                        console.log(`üîç Backspace: line ${lineIndex}, content: "${currentContent}", at start: ${cursorAtStart}`);
                        
                        // If line is empty OR cursor is at start, merge with previous line
                        if ((currentContent.trim() === '' || cursorAtStart) && lineIndex > 0) {
                            e.preventDefault();
                            handleBackspaceAtLineStart(lineIndex);
                        }
                    }
                } else if (e.key === 'Delete') {
                    // Handle delete key for line merging
                    const currentLine = getCurrentLineElement();
                    if (currentLine) {
                        const lineIndex = parseInt(currentLine.dataset.line);
                        const currentContent = currentLine.textContent || '';
                        const cursorAtEnd = isAtLineEnd(currentLine);
                        
                        console.log(`üîç Delete: line ${lineIndex}, content: "${currentContent}", at end: ${cursorAtEnd}`);
                        
                        // If cursor is at end and there's a next line to merge
                        if (cursorAtEnd && lineIndex < editorLines.length - 1) {
                            e.preventDefault();
                            handleDeleteAtLineEnd(lineIndex);
                        }
                    }
                }
            });
            
            // Handle input changes
            hybridEditor.addEventListener('input', () => {
                // Update line contents for current line
                if (currentLineIndex >= 0 && editorLines[currentLineIndex]) {
                    lineContents[currentLineIndex] = editorLines[currentLineIndex].textContent || '';
                    console.log(`üìù Updated line ${currentLineIndex}:`, lineContents[currentLineIndex]);
                }
            });
            
            // Initial render - render all lines as HTML first
            editorLines.forEach((line, index) => {
                renderLineAsHTML(index);
            });
            
            // Then set first line as current (markdown)
            setTimeout(() => {
                currentLineIndex = 0;
                showLineAsMarkdown(0);
                updateLineClasses();
                
                // Focus first line
                if (editorLines[0]) {
                    editorLines[0].focus();
                    
                    // Place cursor at start
                    const range = document.createRange();
                    const selection = window.getSelection();
                    range.setStart(editorLines[0], 0);
                    range.collapse(true);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }, 100);
        }

        // Export functions
        function exportMarkdown() {
            // Collect all line contents as markdown
            const content = lineContents.join('\n');
            downloadFile('document.md', content);
        }

        function exportJSON() {
            const content = lineContents.join('\n');
            if (isWasmReady && editorModule) {
                try {
                    const json = editorModule.ccall('editor_parse_markdown', 'string', ['string'], [content]);
                    downloadFile('document.json', json || JSON.stringify({content}));
                    return;
                } catch (error) {
                    console.warn('WASM JSON export failed:', error);
                }
            }
            
            // Fallback JSON export
            const jsonData = {
                content: content,
                timestamp: new Date().toISOString(),
                version: "1.0"
            };
            downloadFile('document.json', JSON.stringify(jsonData, null, 2));
        }

        function exportHTML() {
            let html = '';
            
            lineContents.forEach(line => {
                if (line.trim()) {
                    const renderedLine = renderSingleLine(line);
                    html += renderedLine + '\n';
                } else {
                    html += '<br>\n';
                }
            });
            
            const fullHtml = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
               max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        h1, h2, h3, h4, h5, h6 { margin-top: 2em; margin-bottom: 0.5em; }
        mark { background: #ffd93d; }
        u { text-decoration: underline; }
    </style>
</head>
<body>
${html}
</body>
</html>`;
            downloadFile('document.html', fullHtml);
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeWasm();
            initializeHybridEditor();
        });
    </script>
</body>
</html>