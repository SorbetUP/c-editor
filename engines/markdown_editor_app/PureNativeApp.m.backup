#import <Cocoa/Cocoa.h>
#import "../editor/editor_abi.h"

@interface RealTimeHybridTextView : NSTextView {
    NSInteger _currentLineIndex;
    BOOL _isUpdating;
}
@end

@implementation RealTimeHybridTextView

- (instancetype)initWithFrame:(NSRect)frameRect {
    self = [super initWithFrame:frameRect];
    if (self) {
        _currentLineIndex = 0;
        _isUpdating = NO;
        
        // Configure text view
        [self setFont:[NSFont fontWithName:@"Monaco" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightRegular]];
        [self setTextColor:[NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0]];
        [self setBackgroundColor:[NSColor colorWithRed:0.118 green:0.118 blue:0.118 alpha:1.0]];
        [self setInsertionPointColor:[NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0]];
        
        // Initial content avec tests de toutes les fonctionnalités
        [self setString:@"# Test Markdown Strict\n\nTests des couleurs :\n- **Gras en vert**\n- *Italique en jaune*\n- ==Surligné en orange==\n- ++Souligné++\n\nTests incomplets :\n- **Gras incomplet\n- *Italique incomplet\n- ==Surligné incomplet\n\n## Test mixte\nTexte avec **gras**, *italique* et ==surligné== ensemble.\n\nListe :\n* Item 1\n+ Item 2\n- Item 3"];
        
        // Start the real-time update
        [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(updateHybridDisplay) userInfo:nil repeats:YES];
    }
    return self;
}

- (NSInteger)getCurrentLineIndex {
    NSRange selectedRange = [self selectedRange];
    NSString *text = [self string];
    
    NSInteger lineIndex = 0;
    NSUInteger currentPos = 0;
    
    for (NSUInteger i = 0; i <= [text length]; i++) {
        if (i == [text length] || [text characterAtIndex:i] == '\n') {
            if (selectedRange.location >= currentPos && selectedRange.location <= i) {
                return lineIndex;
            }
            lineIndex++;
            currentPos = i + 1;
        }
    }
    
    return MAX(0, lineIndex - 1);
}

- (NSArray *)getLines {
    return [[self string] componentsSeparatedByString:@"\n"];
}

- (NSRange)getRangeForLineIndex:(NSInteger)lineIndex {
    NSArray *lines = [self getLines];
    if (lineIndex < 0 || lineIndex >= [lines count]) {
        return NSMakeRange(0, 0);
    }
    
    NSUInteger pos = 0;
    for (NSInteger i = 0; i < lineIndex; i++) {
        pos += [[lines objectAtIndex:i] length] + 1; // +1 for \n
    }
    
    return NSMakeRange(pos, [[lines objectAtIndex:lineIndex] length]);
}

- (void)updateHybridDisplay {
    if (_isUpdating) return;
    
    NSInteger newCurrentLine = [self getCurrentLineIndex];
    if (newCurrentLine == _currentLineIndex) return;
    
    _isUpdating = YES;
    
    // Store current selection
    NSRange oldSelection = [self selectedRange];
    
    // Apply formatting to all lines
    [self applyHybridFormattingForCurrentLine:newCurrentLine];
    
    // Restore selection
    [self setSelectedRange:oldSelection];
    
    _currentLineIndex = newCurrentLine;
    _isUpdating = NO;
}

- (void)applyHybridFormattingForCurrentLine:(NSInteger)currentLine {
    NSMutableAttributedString *text = [[self textStorage] mutableCopy];
    NSArray *lines = [self getLines];
    
    // Apply formatting line by line
    for (NSInteger i = 0; i < [lines count]; i++) {
        NSRange lineRange = [self getRangeForLineIndex:i];
        if (lineRange.length == 0 && i < [lines count] - 1) continue;
        
        NSString *lineContent = [lines objectAtIndex:i];
        
        if (i == currentLine) {
            // Current line: plain markdown with blue background
            [self formatAsCurrentLine:text range:lineRange];
        } else {
            // Other lines: rendered with markdown formatting
            [self formatAsRenderedLine:text range:lineRange content:lineContent];
        }
    }
    
    // Apply the formatting
    [[self textStorage] setAttributedString:text];
}

- (void)formatAsCurrentLine:(NSMutableAttributedString *)text range:(NSRange)range {
    // Ligne sélectionnée avec surlignage bien visible
    NSDictionary *attrs = @{
        NSForegroundColorAttributeName: [NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0],
        NSFontAttributeName: [NSFont fontWithName:@"Monaco" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightRegular],
        NSBackgroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:0.25] // Surlignage bleu plus visible
    };
    
    [text setAttributes:attrs range:range];
}

- (void)formatAsRenderedLine:(NSMutableAttributedString *)text range:(NSRange)range content:(NSString *)content {
    // Base attributes
    NSDictionary *baseAttrs = @{
        NSForegroundColorAttributeName: [NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0],
        NSFontAttributeName: [NSFont fontWithName:@"Monaco" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightRegular],
        NSBackgroundColorAttributeName: [NSColor colorWithRed:1.0 green:1.0 blue:1.0 alpha:0.03] // Subtle background
    };
    
    [text setAttributes:baseAttrs range:range];
    
    // Apply markdown formatting
    [self applyMarkdownFormatting:text inRange:range forContent:content];
}

- (void)applyMarkdownFormatting:(NSMutableAttributedString *)text inRange:(NSRange)baseRange forContent:(NSString *)content {
    if ([content length] == 0) return;
    
    // Headers - cacher les # visuellement
    if ([content hasPrefix:@"# "] && [content length] > 2) {
        [text addAttributes:@{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:20] ?: [NSFont monospacedSystemFontOfSize:20 weight:NSFontWeightBold]
        } range:baseRange];
        // Cacher le # et l'espace
        [text addAttribute:NSForegroundColorAttributeName 
                     value:[NSColor clearColor] 
                     range:NSMakeRange(baseRange.location, 2)];
        return;
    }
    
    if ([content hasPrefix:@"## "] && [content length] > 3) {
        [text addAttributes:@{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:18] ?: [NSFont monospacedSystemFontOfSize:18 weight:NSFontWeightBold]
        } range:baseRange];
        // Cacher le ## et l'espace
        [text addAttribute:NSForegroundColorAttributeName 
                     value:[NSColor clearColor] 
                     range:NSMakeRange(baseRange.location, 3)];
        return;
    }
    
    // Bold **text** - VERT et cacher les **
    [self applyRegexFormattingAndHide:text 
                              inRange:baseRange 
                              pattern:@"(\\*\\*)([^*\\n]+)(\\*\\*)" 
                           attributes:@{
                               NSForegroundColorAttributeName: [NSColor colorWithRed:0.318 green:0.812 blue:0.400 alpha:1.0], // VERT
                               NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightBold]
                           }];
    
    // Italic *text* - JAUNE et cacher les *
    [self applyRegexFormattingAndHide:text 
                              inRange:baseRange 
                              pattern:@"(?<!\\*)(\\*)([^*\\n]+)(\\*)(?!\\*)" 
                           attributes:@{
                               NSForegroundColorAttributeName: [NSColor colorWithRed:1.0 green:0.85 blue:0.24 alpha:1.0] // JAUNE
                           }];
    
    // Highlight ==text== - ORANGE et cacher les ==
    [self applyRegexFormattingAndHide:text 
                              inRange:baseRange 
                              pattern:@"(==)([^=\\n]+)(==)" 
                           attributes:@{
                               NSBackgroundColorAttributeName: [NSColor colorWithRed:1.0 green:0.65 blue:0.0 alpha:0.8], // ORANGE
                               NSForegroundColorAttributeName: [NSColor blackColor]
                           }];
    
    // List items
    if ([content hasPrefix:@"- "] || [content hasPrefix:@"* "] || [content hasPrefix:@"+ "]) {
        NSRange bulletRange = NSMakeRange(baseRange.location, 2);
        [text addAttribute:NSForegroundColorAttributeName 
                     value:[NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0] // Blue bullet
                     range:bulletRange];
    }
}

- (void)applyRegexFormattingAndHide:(NSMutableAttributedString *)text 
                            inRange:(NSRange)baseRange 
                            pattern:(NSString *)pattern 
                         attributes:(NSDictionary *)attributes {
    
    NSString *lineText = [text.string substringWithRange:baseRange];
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&error];
    
    if (error) return;
    
    NSArray *matches = [regex matchesInString:lineText options:0 range:NSMakeRange(0, [lineText length])];
    
    for (NSTextCheckingResult *match in [matches reverseObjectEnumerator]) {
        if ([match numberOfRanges] >= 4) { // Pattern avec 3 groupes : (markup)(content)(markup)
            NSRange openMarkup = [match rangeAtIndex:1];  // ** ou * ou ==
            NSRange content = [match rangeAtIndex:2];     // le texte
            NSRange closeMarkup = [match rangeAtIndex:3]; // ** ou * ou ==
            
            // Appliquer le formatage sur tout le match
            NSRange fullMatch = NSMakeRange(baseRange.location + match.range.location, match.range.length);
            [text addAttributes:attributes range:fullMatch];
            
            // Cacher les caractères de markup (rendre transparents)
            NSRange openRange = NSMakeRange(baseRange.location + openMarkup.location, openMarkup.length);
            NSRange closeRange = NSMakeRange(baseRange.location + closeMarkup.location, closeMarkup.length);
            
            [text addAttribute:NSForegroundColorAttributeName 
                         value:[NSColor clearColor] 
                         range:openRange];
            [text addAttribute:NSForegroundColorAttributeName 
                         value:[NSColor clearColor] 
                         range:closeRange];
        }
    }
        };
        [text addAttributes:attrs range:baseRange];
        return;
    }
    
    if ([content hasPrefix:@"## "] && [content length] > 3) {
        NSDictionary *attrs = @{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:18] ?: [NSFont monospacedSystemFontOfSize:18 weight:NSFontWeightBold]
        };
        [text addAttributes:attrs range:baseRange];
        return;
    }
    
    if ([content hasPrefix:@"### "] && [content length] > 4) {
        NSDictionary *attrs = @{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:16] ?: [NSFont monospacedSystemFontOfSize:16 weight:NSFontWeightBold]
        };
        [text addAttributes:attrs range:baseRange];
        return;
    }
    
    // Bold **text** - VERT selon les règles Markdown strictes
    [self applyRegexFormatting:text 
                       inRange:baseRange 
                       pattern:@"\\*\\*([^*\\n]+)\\*\\*" 
                    attributes:@{
                        NSForegroundColorAttributeName: [NSColor colorWithRed:0.318 green:0.812 blue:0.400 alpha:1.0], // VERT
                        NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightBold]
                    }];
    
    // Italic *text* - JAUNE selon les règles Markdown strictes  
    [self applyRegexFormatting:text 
                       inRange:baseRange 
                       pattern:@"(?<!\\*)\\*([^*\\n]+)\\*(?!\\*)" 
                    attributes:@{
                        NSForegroundColorAttributeName: [NSColor colorWithRed:1.0 green:0.85 blue:0.24 alpha:1.0], // JAUNE
                        NSFontAttributeName: [NSFont fontWithName:@"Monaco" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightRegular]
                    }];
    
    // Highlight ==text== - ORANGE (corrigé pour fonctionner)
    [self applyRegexFormatting:text 
                       inRange:baseRange 
                       pattern:@"==([^=\\n]+)==" 
                    attributes:@{
                        NSBackgroundColorAttributeName: [NSColor colorWithRed:1.0 green:0.65 blue:0.0 alpha:0.8], // ORANGE
                        NSForegroundColorAttributeName: [NSColor blackColor]
                    }];
    
    // Underline ++text++ selon les règles étendues
    [self applyRegexFormatting:text 
                       inRange:baseRange 
                       pattern:@"\\+\\+([^+\\n]+)\\+\\+" 
                    attributes:@{
                        NSForegroundColorAttributeName: [NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0],
                        NSUnderlineStyleAttributeName: @(NSUnderlineStyleSingle)
                    }];
    
    // List items
    if ([content hasPrefix:@"- "] || [content hasPrefix:@"* "] || [content hasPrefix:@"+ "]) {
        NSRange bulletRange = NSMakeRange(baseRange.location, 2);
        [text addAttribute:NSForegroundColorAttributeName 
                     value:[NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0] 
                     range:bulletRange];
    }
}

- (void)renderWithCEngineAndHideMarkup:(NSMutableAttributedString *)text inRange:(NSRange)baseRange content:(NSString *)content {
    // Utiliser la lib C pour convertir markdown vers HTML
    const char *html = editor_markdown_to_html([content UTF8String]);
    if (!html) return;
    
    NSString *htmlString = [NSString stringWithUTF8String:html];
    
    // Convertir HTML simple en texte formaté sans markup
    NSString *renderedText = [self convertHTMLToPlainTextWithFormatting:htmlString];
    
    // Remplacer le contenu original par le texte rendu
    [text replaceCharactersInRange:baseRange withString:renderedText];
    
    // Appliquer le formatage sur le nouveau texte
    NSRange newRange = NSMakeRange(baseRange.location, [renderedText length]);
    [self applyFormattingToRenderedText:text inRange:newRange originalHTML:htmlString];
}

- (NSString *)convertHTMLToPlainTextWithFormatting:(NSString *)html {
    NSString *text = html;
    
    // Enlever les balises HTML en gardant seulement le contenu
    text = [text stringByReplacingOccurrencesOfString:@"<h1>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</h1>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<h2>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</h2>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<h3>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</h3>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<strong>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</strong>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<em>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</em>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<mark>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</mark>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<u>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"</u>" withString:@""];
    text = [text stringByReplacingOccurrencesOfString:@"<li>" withString:@"• "];
    text = [text stringByReplacingOccurrencesOfString:@"</li>" withString:@""];
    
    return text;
}

- (void)applyFormattingToRenderedText:(NSMutableAttributedString *)text inRange:(NSRange)range originalHTML:(NSString *)html {
    NSString *content = [text.string substringWithRange:range];
    
    // Headers - détectés par la taille du contenu original
    if ([html containsString:@"<h1>"]) {
        [text addAttributes:@{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:20] ?: [NSFont monospacedSystemFontOfSize:20 weight:NSFontWeightBold]
        } range:range];
        return;
    }
    if ([html containsString:@"<h2>"]) {
        [text addAttributes:@{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:18] ?: [NSFont monospacedSystemFontOfSize:18 weight:NSFontWeightBold]
        } range:range];
        return;
    }
    if ([html containsString:@"<h3>"]) {
        [text addAttributes:@{
            NSForegroundColorAttributeName: [NSColor colorWithRed:0.298 green:0.431 blue:0.961 alpha:1.0],
            NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:16] ?: [NSFont monospacedSystemFontOfSize:16 weight:NSFontWeightBold]
        } range:range];
        return;
    }
    
    // Pour le formatage inline, rechercher les balises HTML et appliquer sur le texte correspondant
    [self applyInlineFormatting:text inRange:range originalHTML:html];
}

- (void)applyInlineFormatting:(NSMutableAttributedString *)text inRange:(NSRange)baseRange originalHTML:(NSString *)html {
    // Pour les balises inline, on doit mapper les positions HTML vers les positions text
    NSString *content = [text.string substringWithRange:baseRange];
    
    // Bold - chercher le texte entre <strong></strong>
    NSRegularExpression *boldRegex = [NSRegularExpression regularExpressionWithPattern:@"<strong>([^<]+)</strong>" options:0 error:nil];
    NSArray *boldMatches = [boldRegex matchesInString:html options:0 range:NSMakeRange(0, [html length])];
    for (NSTextCheckingResult *match in boldMatches) {
        NSString *boldText = [html substringWithRange:[match rangeAtIndex:1]];
        NSRange textRange = [content rangeOfString:boldText];
        if (textRange.location != NSNotFound) {
            NSRange actualRange = NSMakeRange(baseRange.location + textRange.location, textRange.length);
            [text addAttributes:@{
                NSForegroundColorAttributeName: [NSColor colorWithRed:0.318 green:0.812 blue:0.400 alpha:1.0], // VERT
                NSFontAttributeName: [NSFont fontWithName:@"Monaco-Bold" size:14] ?: [NSFont monospacedSystemFontOfSize:14 weight:NSFontWeightBold]
            } range:actualRange];
        }
    }
    
    // Italic
    NSRegularExpression *italicRegex = [NSRegularExpression regularExpressionWithPattern:@"<em>([^<]+)</em>" options:0 error:nil];
    NSArray *italicMatches = [italicRegex matchesInString:html options:0 range:NSMakeRange(0, [html length])];
    for (NSTextCheckingResult *match in italicMatches) {
        NSString *italicText = [html substringWithRange:[match rangeAtIndex:1]];
        NSRange textRange = [content rangeOfString:italicText];
        if (textRange.location != NSNotFound) {
            NSRange actualRange = NSMakeRange(baseRange.location + textRange.location, textRange.length);
            [text addAttribute:NSForegroundColorAttributeName 
                         value:[NSColor colorWithRed:1.0 green:0.85 blue:0.24 alpha:1.0] // JAUNE
                         range:actualRange];
        }
    }
    
    // Highlight
    NSRegularExpression *markRegex = [NSRegularExpression regularExpressionWithPattern:@"<mark>([^<]+)</mark>" options:0 error:nil];
    NSArray *markMatches = [markRegex matchesInString:html options:0 range:NSMakeRange(0, [html length])];
    for (NSTextCheckingResult *match in markMatches) {
        NSString *markText = [html substringWithRange:[match rangeAtIndex:1]];
        NSRange textRange = [content rangeOfString:markText];
        if (textRange.location != NSNotFound) {
            NSRange actualRange = NSMakeRange(baseRange.location + textRange.location, textRange.length);
            [text addAttributes:@{
                NSBackgroundColorAttributeName: [NSColor colorWithRed:1.0 green:0.65 blue:0.0 alpha:0.8], // ORANGE
                NSForegroundColorAttributeName: [NSColor blackColor]
            } range:actualRange];
        }
    }
}

- (void)applyRegexFormatting:(NSMutableAttributedString *)text 
                     inRange:(NSRange)baseRange 
                     pattern:(NSString *)pattern 
                  attributes:(NSDictionary *)attributes {
    
    NSString *lineText = [text.string substringWithRange:baseRange];
    NSError *error = nil;
    NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:pattern options:0 error:&error];
    
    if (error) {
        return;
    }
    
    NSArray *matches = [regex matchesInString:lineText options:0 range:NSMakeRange(0, [lineText length])];
    
    // Appliquer les matches en ordre inverse pour éviter les conflits de range
    for (NSTextCheckingResult *match in [matches reverseObjectEnumerator]) {
        NSRange matchRange = NSMakeRange(baseRange.location + match.range.location, match.range.length);
        if (NSMaxRange(matchRange) <= NSMaxRange(baseRange)) { // Vérification de sécurité
            [text addAttributes:attributes range:matchRange];
        }
    }
}

// Override events to trigger updates
- (void)keyDown:(NSEvent *)event {
    [super keyDown:event];
    // Immediate update after key press
    dispatch_async(dispatch_get_main_queue(), ^{
        [self updateHybridDisplay];
    });
}

- (void)mouseDown:(NSEvent *)event {
    [super mouseDown:event];
    // Immediate update after click
    dispatch_async(dispatch_get_main_queue(), ^{
        [self updateHybridDisplay];
    });
}

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSApplication *app = [NSApplication sharedApplication];
        [app setActivationPolicy:NSApplicationActivationPolicyRegular];
        
        // Initialize C engine
        editor_library_init();
        
        // Create window
        NSRect frame = NSMakeRect(100, 100, 1000, 700);
        NSWindow *window = [[NSWindow alloc] 
            initWithContentRect:frame
            styleMask:(NSWindowStyleMaskTitled | NSWindowStyleMaskClosable | NSWindowStyleMaskResizable | NSWindowStyleMaskMiniaturizable)
            backing:NSBackingStoreBuffered 
            defer:NO];
        
        [window setTitle:@"ElephantNotes"];
        [window setBackgroundColor:[NSColor colorWithRed:0.102 green:0.102 blue:0.102 alpha:1.0]];
        
        // Header
        NSView *headerView = [[NSView alloc] initWithFrame:NSMakeRect(0, frame.size.height - 60, frame.size.width, 60)];
        [headerView setWantsLayer:YES];
        [headerView layer].backgroundColor = [NSColor colorWithRed:0.176 green:0.176 blue:0.176 alpha:1.0].CGColor;
        [headerView setAutoresizingMask:NSViewWidthSizable | NSViewMinYMargin];
        
        NSTextField *titleLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 20, 400, 20)];
        [titleLabel setStringValue:@"ElephantNotes"];
        [titleLabel setTextColor:[NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0]];
        [titleLabel setBackgroundColor:[NSColor clearColor]];
        [titleLabel setBordered:NO];
        [titleLabel setEditable:NO];
        [titleLabel setFont:[NSFont systemFontOfSize:16 weight:NSFontWeightSemibold]];
        [headerView addSubview:titleLabel];
        
        NSView *statusIndicator = [[NSView alloc] initWithFrame:NSMakeRect(frame.size.width - 200, 25, 8, 8)];
        [statusIndicator setWantsLayer:YES];
        [statusIndicator layer].backgroundColor = [NSColor colorWithRed:0.318 green:0.812 blue:0.4 alpha:1.0].CGColor;
        [statusIndicator layer].cornerRadius = 4;
        [statusIndicator setAutoresizingMask:NSViewMinXMargin];
        [headerView addSubview:statusIndicator];
        
        NSTextField *statusLabel = [[NSTextField alloc] initWithFrame:NSMakeRect(frame.size.width - 180, 20, 150, 15)];
        [statusLabel setStringValue:@"Markdown Editor Ready"];
        [statusLabel setTextColor:[NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0]];
        [statusLabel setBackgroundColor:[NSColor clearColor]];
        [statusLabel setBordered:NO];
        [statusLabel setEditable:NO];
        [statusLabel setFont:[NSFont systemFontOfSize:12]];
        [statusLabel setAutoresizingMask:NSViewMinXMargin];
        [headerView addSubview:statusLabel];
        
        // Pane header
        NSView *paneHeader = [[NSView alloc] initWithFrame:NSMakeRect(0, frame.size.height - 110, frame.size.width, 50)];
        [paneHeader setWantsLayer:YES];
        [paneHeader layer].backgroundColor = [NSColor colorWithRed:0.176 green:0.176 blue:0.176 alpha:1.0].CGColor;
        [paneHeader setAutoresizingMask:NSViewWidthSizable | NSViewMinYMargin];
        
        NSTextField *paneTitle = [[NSTextField alloc] initWithFrame:NSMakeRect(20, 15, 700, 20)];
        [paneTitle setStringValue:@"ElephantNotes - Éditeur Markdown Hybride - Ligne courante en Markdown, autres rendues"];
        [paneTitle setTextColor:[NSColor colorWithRed:0.878 green:0.878 blue:0.878 alpha:1.0]];
        [paneTitle setBackgroundColor:[NSColor clearColor]];
        [paneTitle setBordered:NO];
        [paneTitle setEditable:NO];
        [paneTitle setFont:[NSFont systemFontOfSize:14 weight:NSFontWeightSemibold]];
        [paneHeader addSubview:paneTitle];
        
        // Create scroll view
        NSScrollView *scrollView = [[NSScrollView alloc] initWithFrame:NSMakeRect(20, 20, frame.size.width - 40, frame.size.height - 150)];
        [scrollView setHasVerticalScroller:YES];
        [scrollView setHasHorizontalScroller:NO];
        [scrollView setAutohidesScrollers:YES];
        [scrollView setBorderType:NSLineBorder];
        [scrollView setBackgroundColor:[NSColor colorWithRed:0.118 green:0.118 blue:0.118 alpha:1.0]];
        [scrollView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
        
        // Create the hybrid text view
        RealTimeHybridTextView *textView = [[RealTimeHybridTextView alloc] initWithFrame:[scrollView.contentView bounds]];
        [textView setVerticallyResizable:YES];
        [textView setHorizontallyResizable:NO];
        [textView setAutoresizingMask:NSViewWidthSizable];
        [[textView textContainer] setWidthTracksTextView:YES];
        [[textView textContainer] setContainerSize:NSMakeSize([scrollView.contentView bounds].size.width, FLT_MAX)];
        
        [scrollView setDocumentView:textView];
        
        // Add views to window
        [[window contentView] addSubview:headerView];
        [[window contentView] addSubview:paneHeader];
        [[window contentView] addSubview:scrollView];
        
        // Show window and focus
        [window makeKeyAndOrderFront:nil];
        [window center];
        [window makeFirstResponder:textView];
        
        
        [app run];
    }
    return 0;
}