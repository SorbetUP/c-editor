<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C Editor Web - √âditeur Markdown</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #2d2d2d;
            padding: 10px 20px;
            border-bottom: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 18px;
            color: #fff;
        }

        .header .status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6b6b;
        }

        .status-indicator.ready {
            background: #51cf66;
        }

        .buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            background: #4c6ef5;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #364fc7;
        }

        .btn:disabled {
            background: #555;
            cursor: not-allowed;
        }

        .main-content {
            display: flex;
            height: calc(100vh - 60px);
        }

        .hybrid-editor {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .pane-header {
            background: #2d2d2d;
            padding: 10px 20px;
            border-bottom: 1px solid #444;
            font-weight: 600;
            font-size: 14px;
        }

        .hybrid-editor-container {
            flex: 1;
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        #hybridEditor {
            width: 50%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.8;
            overflow-y: auto;
            outline: none;
            resize: none;
        }

        #hybridEditor:focus {
            border-color: #4c6ef5;
        }

        #hybridPreview {
            width: 50%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
            line-height: 1.8;
            overflow-y: auto;
        }

        .hybrid-line {
            min-height: 1.8em;
            padding: 2px 0;
            margin: 0;
        }

        .hybrid-line.current {
            background-color: rgba(76, 110, 245, 0.1);
            border-left: 3px solid #4c6ef5;
            padding-left: 10px;
        }

        /* Markdown styling */
        #preview h1, #preview h2, #preview h3, #preview h4, #preview h5, #preview h6 {
            margin: 20px 0 10px 0;
            color: #fff;
        }

        #preview h1 { font-size: 28px; }
        #preview h2 { font-size: 24px; }
        #preview h3 { font-size: 20px; }

        #preview p {
            margin: 10px 0;
        }

        #preview strong {
            color: #fff;
        }

        #preview em {
            color: #ffd93d;
        }

        #preview table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }

        #preview th, #preview td {
            border: 1px solid #444;
            padding: 8px 12px;
            text-align: left;
        }

        #preview th {
            background: #2d2d2d;
            color: #fff;
        }

        .footer {
            background: #2d2d2d;
            padding: 8px 20px;
            border-top: 1px solid #444;
            font-size: 12px;
            color: #888;
            text-align: center;
        }

        /* File input hidden */
        #fileInput {
            display: none;
        }

        .dropdown {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background: #2d2d2d;
            min-width: 150px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            border: 1px solid #444;
            border-radius: 4px;
            z-index: 1;
        }

        .dropdown-content button {
            color: #e0e0e0;
            padding: 10px 16px;
            text-decoration: none;
            display: block;
            width: 100%;
            text-align: left;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 12px;
        }

        .dropdown-content button:hover {
            background: #404040;
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>C Editor Web</h1>
        <div class="status">
            <span class="status-indicator" id="statusIndicator"></span>
            <span id="statusText">Chargement...</span>
        </div>
        <div class="buttons">
            <div class="dropdown">
                <button class="btn">Export ‚ñæ</button>
                <div class="dropdown-content">
                    <button onclick="exportMarkdown()">üìÑ Export Markdown</button>
                    <button onclick="exportJSON()">üìã Export JSON</button>
                    <button onclick="exportHTML()">üåê Export HTML</button>
                </div>
            </div>
            <button class="btn" onclick="importFile()">üìÅ Import</button>
            <button class="btn" onclick="testRenderAll()" style="background: #ff6b6b;">üîß Test Render All</button>
        </div>
    </div>

    <div class="main-content">
        <div class="hybrid-editor">
            <div class="pane-header">√âditeur Hybride - Ligne courante en Markdown, autres lignes rendues</div>
            <div class="hybrid-editor-container">
                <textarea id="hybridEditor" spellcheck="false" placeholder="√âcrivez votre markdown ici..."># Titre

√âcrivez votre markdown ici...

Exemple:
- **Gras**
- *Italique*
- ==Surlign√©==
- ++Soulign√©++</textarea>
                <div id="hybridPreview"></div>
            </div>
        </div>
    </div>

    <div class="footer">
        C Editor Web - Powered by Emscripten WASM | 
        <a href="https://github.com/SorbetUP/c-editor" style="color: #4c6ef5;">GitHub</a>
    </div>

    <input type="file" id="fileInput" accept=".md,.json,.txt" style="display: none;">

    <script src="editor.js"></script>
    <script>
        let editorModule = null;
        let isWasmReady = false;
        
        const hybridEditor = document.getElementById('hybridEditor');
        const hybridPreview = document.getElementById('hybridPreview');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        
        let currentCursorLine = 0;
        let lastRenderedLines = [];

        // Initialize WASM module
        async function initializeWasm() {
            try {
                statusText.textContent = 'Chargement WASM...';
                
                // Wait for EditorModule to be available
                let attempts = 0;
                const maxAttempts = 50;
                
                while (typeof EditorModule === 'undefined' && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                    console.log('Waiting for EditorModule... attempt', attempts);
                }
                
                if (typeof EditorModule !== 'undefined') {
                    console.log('EditorModule found, initializing...');
                    editorModule = await EditorModule();
                    isWasmReady = true;
                    statusIndicator.classList.add('ready');
                    statusText.textContent = 'WASM Ready';
                    console.log('WASM module loaded successfully');
                    
                    // Re-render if there's already content
                    console.log('WASM ready, will render lines when hybrid editor is initialized');
                } else {
                    throw new Error('EditorModule not found after ' + maxAttempts + ' attempts');
                }
            } catch (error) {
                console.warn('WASM not available:', error);
                statusIndicator.style.background = '#ff6b6b';
                statusText.textContent = '‚ùå WASM indisponible';
                isWasmReady = false;
            }
        }

        // Simple markdown renderer fallback
        function renderMarkdownFallback(text) {
            if (!text) return 'Le rendu appara√Ætra ici en temps r√©el...';
            
            const lines = text.split('\n');
            let html = '';
            let inTable = false;
            let tableHtml = '';
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                // Handle tables
                if (line.includes('|') && line.trim().length > 0 && !line.match(/^\s*\|?\s*-+\s*\|/)) {
                    if (!inTable) {
                        if (html) html += '\n';
                        tableHtml = '<table>';
                        inTable = true;
                    }
                    
                    const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');
                    
                    const isHeader = i === 0 || (i > 0 && lines[i+1] && lines[i+1].match(/^\s*\|?\s*-+\s*\|/));
                    const tag = isHeader ? 'th' : 'td';
                    
                    tableHtml += '<tr>';
                    cells.forEach(cell => {
                        // Apply inline formatting to cell content
                        let cellContent = cell
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/==(.*?)==/g, '<mark style="background: #ffd93d; color: #000;">$1</mark>')
                            .replace(/\+\+(.*?)\+\+/g, '<u>$1</u>');
                        tableHtml += `<${tag}>${cellContent}</${tag}>`;
                    });
                    tableHtml += '</tr>';
                    continue;
                } else if (inTable && !line.match(/^\s*\|?\s*-+\s*\|/)) {
                    // End table
                    tableHtml += '</table>';
                    html += tableHtml;
                    tableHtml = '';
                    inTable = false;
                }
                
                // Skip table separator lines
                if (line.match(/^\s*\|?\s*-+\s*\|/)) {
                    continue;
                }
                
                // Handle headers
                if (line.match(/^#{1,6}\s/)) {
                    const level = line.match(/^#+/)[0].length;
                    const content = line.replace(/^#+\s*/, '');
                    html += `<h${level}>${content}</h${level}>`;
                }
                // Handle empty lines
                else if (line.trim() === '') {
                    if (!inTable) html += '<br>';
                }
                // Handle regular text
                else if (!inTable) {
                    // Apply inline formatting
                    let formattedLine = line
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/==(.*?)==/g, '<mark style="background: #ffd93d; color: #000;">$1</mark>')
                        .replace(/\+\+(.*?)\+\+/g, '<u>$1</u>');
                    
                    html += `<p>${formattedLine}</p>`;
                }
            }
            
            // Close any open table
            if (inTable) {
                tableHtml += '</table>';
                html += tableHtml;
            }

            return html;
        }

        // Convert JSON from C engine to HTML
        function jsonToHtml(jsonStr) {
            try {
                const doc = JSON.parse(jsonStr);
                if (!doc.elements) {
                    return 'Erreur: pas d\'√©l√©ments trouv√©s';
                }
                
                let html = '';
                
                // Group elements by lines based on patterns in the original markdown
                let lines = [];
                let currentLine = [];
                
                for (let i = 0; i < doc.elements.length; i++) {
                    const element = doc.elements[i];
                    if (element.type === 'text') {
                        
                        // Start new line for headers
                        if (element.level > 0) {
                            if (currentLine.length > 0) {
                                lines.push([...currentLine]);
                                currentLine = [];
                            }
                            currentLine.push(element);
                            lines.push([...currentLine]);
                            currentLine = [];
                        } else {
                            // For level 0 elements, detect line breaks from markdown patterns
                            // Based on your input: "== le chat ==", "*l*", "**le**", "***le***", "++le++"
                            
                            if (element.text.trim() && currentLine.length > 0) {
                                // Check if this looks like a new markdown line
                                const prevElement = currentLine[currentLine.length - 1];
                                
                                // New line if:
                                // 1. Text doesn't start with space and previous doesn't end with space
                                // 2. Significant style change
                                if (!element.text.startsWith(' ') && !prevElement.text.endsWith(' ')) {
                                    // Looks like separate markdown elements -> new line
                                    lines.push([...currentLine]);
                                    currentLine = [element];
                                } else {
                                    currentLine.push(element);
                                }
                            } else {
                                currentLine.push(element);
                            }
                        }
                    }
                }
                
                // Add remaining line
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }
                
                // Render each line
                for (const line of lines) {
                    if (line.length === 0) continue;
                    
                    let lineHtml = '';
                    let lineLevel = line[0].level;
                    
                    for (const element of line) {
                        lineHtml += renderTextElement(element);
                    }
                    
                    html += wrapLine(lineHtml, lineLevel);
                }
                
                return html || 'Rendu vide';
            } catch (error) {
                console.warn('JSON parsing error:', error);
                return 'Erreur de parsing JSON: ' + error.message;
            }
        }
        
        function renderTextElement(element) {
            // If element has spans, render each span separately
            if (element.spans && element.spans.length > 0) {
                let html = '';
                for (const span of element.spans) {
                    html += renderSpan(span);
                }
                return html;
            }
            
            // Fallback to element-level formatting
            let text = element.text || '';
            let html = text;
            
            // Apply formatting
            if (element.bold && element.italic) {
                html = `<strong><em>${html}</em></strong>`;
            } else if (element.bold) {
                html = `<strong>${html}</strong>`;
            } else if (element.italic) {
                html = `<em>${html}</em>`;
            }
            
            // Apply highlight
            if (element.highlight) {
                const [r, g, b, a] = element.highlight.color;
                const bgColor = `rgba(${r*255}, ${g*255}, ${b*255}, ${a})`;
                html = `<mark style="background-color: ${bgColor};">${html}</mark>`;
            }
            
            // Apply underline
            if (element.underline) {
                const [r, g, b, a] = element.underline.color;
                const underlineColor = `rgba(${r*255}, ${g*255}, ${b*255}, ${a})`;
                html = `<u style="text-decoration-color: ${underlineColor};">${html}</u>`;
            }
            
            // Apply color
            if (element.color) {
                const [r, g, b, a] = element.color;
                const color = `rgba(${r*255}, ${g*255}, ${b*255}, ${a})`;
                html = `<span style="color: ${color};">${html}</span>`;
            }
            
            return html;
        }
        
        function renderSpan(span) {
            let text = span.text || '';
            let html = text;
            
            // Apply formatting
            if (span.bold && span.italic) {
                html = `<strong><em>${html}</em></strong>`;
            } else if (span.bold) {
                html = `<strong>${html}</strong>`;
            } else if (span.italic) {
                html = `<em>${html}</em>`;
            }
            
            // Apply highlight
            if (span.has_highlight && span.highlight_color) {
                const [r, g, b, a] = span.highlight_color;
                const bgColor = `rgba(${r*255}, ${g*255}, ${b*255}, ${a})`;
                html = `<mark style="background: ${bgColor}; color: #000;">${html}</mark>`;
            }
            
            // Apply underline
            if (span.has_underline) {
                html = `<u>${html}</u>`;
            }
            
            return html;
        }
        
        function wrapLine(content, level) {
            if (level > 0) {
                // Header level
                return `<h${Math.min(level, 6)}>${content}</h${Math.min(level, 6)}>`;
            } else {
                // Regular paragraph
                return `<p>${content}</p>`;
            }
        }
        
        // Parse inline formatting and create separate elements
        function fixInlineFormatting(originalText, jsonStr) {
            try {
                const doc = JSON.parse(jsonStr);
                
                if (!doc.elements || doc.elements.length === 0) {
                    return jsonStr;
                }
                
                // Parse the original text and create separate elements
                const parsedElements = parseInlineElements(originalText, doc.elements[0]);
                
                if (parsedElements.length > 1) {
                    doc.elements = parsedElements;
                    console.log(`Separated into ${parsedElements.length} elements:`, parsedElements.map(e => `"${e.text}"`));
                }
                
                return JSON.stringify(doc);
            } catch (error) {
                console.warn('Error fixing inline formatting:', error);
                return jsonStr;
            }
        }
        
        // Parse text with inline formatting into separate elements
        function parseInlineElements(text, baseElement) {
            const elements = [];
            let currentIndex = 0;
            
            // Define formatting patterns in order of precedence
            const patterns = [
                { regex: /\*\*\*(.+?)\*\*\*/, bold: true, italic: true },
                { regex: /\*\*(.+?)\*\*/, bold: true, italic: false },
                { regex: /\*(.+?)\*/, bold: false, italic: true },
                { regex: /==(.+?)==/, highlight: true },
                { regex: /\+\+(.+?)\+\+/, underline: true }
            ];
            
            while (currentIndex < text.length) {
                let foundMatch = false;
                let earliestMatch = null;
                let earliestIndex = text.length;
                
                // Find the earliest formatting pattern
                for (const pattern of patterns) {
                    const match = text.slice(currentIndex).match(pattern.regex);
                    if (match && match.index < earliestIndex - currentIndex) {
                        earliestMatch = {
                            ...pattern,
                            match: match,
                            startIndex: currentIndex + match.index,
                            endIndex: currentIndex + match.index + match[0].length
                        };
                        earliestIndex = earliestMatch.startIndex;
                    }
                }
                
                if (earliestMatch) {
                    // Add text before the formatting (if any)
                    if (earliestMatch.startIndex > currentIndex) {
                        const beforeText = text.slice(currentIndex, earliestMatch.startIndex);
                        elements.push({
                            type: "text",
                            text: beforeText,
                            align: baseElement.align,
                            color: baseElement.color,
                            bold: false,
                            italic: false,
                            level: baseElement.level
                        });
                    }
                    
                    // Add the formatted element
                    const formattedElement = {
                        type: "text",
                        text: earliestMatch.match[1],
                        align: baseElement.align,
                        color: baseElement.color,
                        bold: earliestMatch.bold || false,
                        italic: earliestMatch.italic || false,
                        level: baseElement.level
                    };
                    
                    if (earliestMatch.highlight) {
                        formattedElement.highlight = { color: [1.000, 1.000, 0.000, 0.300] };
                    }
                    if (earliestMatch.underline) {
                        formattedElement.underline = { color: [0.000, 0.000, 0.000, 0.400], gap: 7 };
                    }
                    
                    elements.push(formattedElement);
                    currentIndex = earliestMatch.endIndex;
                    foundMatch = true;
                } else {
                    // No more formatting, add remaining text
                    const remainingText = text.slice(currentIndex);
                    if (remainingText) {
                        elements.push({
                            type: "text",
                            text: remainingText,
                            align: baseElement.align,
                            color: baseElement.color,
                            bold: false,
                            italic: false,
                            level: baseElement.level
                        });
                    }
                    break;
                }
            }
            
            return elements.length > 0 ? elements : [baseElement];
        }
        
        // Pre-process text to separate inline formatting for the C engine
        function preprocessInlineFormatting(text) {
            // This is a workaround: instead of sending "***le*** ==chat==" as one line,
            // we could try to hint the C parser to separate elements
            // But this approach might be complex. Let's try a different strategy.
            
            // For now, return the original text and handle the separation in post-processing
            console.log('Preprocessing text:', text);
            return text;
        }

        // Render markdown using WASM or fallback
        async function renderMarkdown(text) {
            // Si WASM n'est pas encore pr√™t, attendre un peu
            if (!isWasmReady && !editorModule) {
                let attempts = 0;
                const maxWait = 10; // 1 seconde max
                
                while (!isWasmReady && attempts < maxWait) {
                    console.log('Waiting for WASM to be ready...', attempts);
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
            }
            
            console.log('renderMarkdown called with:', text.substring(0, 50));
            console.log('isWasmReady:', isWasmReady, 'editorModule:', !!editorModule);
            
            if (isWasmReady && editorModule) {
                try {
                    console.log('Trying WASM functions...');
                    
                    // Initialize library (idempotent)
                    editorModule.ccall('editor_library_init', null, [], []);
                    
                    // Pre-process text to separate inline formatting
                    const processedText = preprocessInlineFormatting(text);
                    
                    // Utiliser la fonction simple qui retourne directement le JSON
                    const jsonResult = editorModule.ccall('editor_parse_markdown_simple', 'string', ['string'], [processedText]);
                    
                    if (jsonResult) {
                        console.log('Using C markdown engine ‚úÖ');
                        console.log('Full JSON from C engine:', jsonResult);
                        
                        return jsonToHtml(jsonResult);
                    } else {
                        console.log('C function returned null');
                        const errorMsg = editorModule.ccall('editor_get_error_message', 'string', [], []);
                        console.log('Error message:', errorMsg || 'No error message available');
                        return '<p style="color: orange;">‚ö†Ô∏è R√©sultat vide du moteur C</p>';
                    }
                } catch (error) {
                    console.warn('WASM render failed:', error);
                    return '<p style="color: orange;">‚ö†Ô∏è Erreur moteur markdown C: ' + error.message + '</p>';
                }
            }
            
            console.log('WASM not available - showing loading message');
            return '<p style="color: #ffd93d;">üîÑ Chargement du moteur markdown...</p>';
        }

        // Cache for rendered lines
        let cachedLines = [];
        let lastText = '';
        
        // Update preview - only re-render changed lines
        async function updatePreview() {
            const text = editor.value;
            const lines = text.split('\n');
            
            // Find which line changed
            const lastLines = lastText.split('\n');
            
            // Create array to hold rendered lines
            let renderedLines = [...cachedLines];
            
            // Extend arrays to match current length
            while (renderedLines.length < lines.length) {
                renderedLines.push('');
            }
            
            // Check each line for changes
            for (let i = 0; i < lines.length; i++) {
                const currentLine = lines[i];
                const lastLine = i < lastLines.length ? lastLines[i] : '';
                
                // Only re-render if line changed
                if (currentLine !== lastLine) {
                    console.log(`Re-rendering line ${i}: "${currentLine}"`);
                    
                    if (currentLine.trim()) {
                        const lineHtml = await renderMarkdown(currentLine.trim());
                        renderedLines[i] = lineHtml;
                    } else {
                        renderedLines[i] = '<br>'; // Empty line
                    }
                }
            }
            
            // Remove excess lines if text got shorter
            if (renderedLines.length > lines.length) {
                renderedLines = renderedLines.slice(0, lines.length);
            }
            
            // Update cache
            cachedLines = [...renderedLines];
            lastText = text;
            
            // Update DOM
            preview.innerHTML = renderedLines.join('');
        }

        // Export functions
        function exportMarkdown() {
            const content = hybridEditor.textContent;
            downloadFile('document.md', content);
        }

        function exportJSON() {
            const content = hybridEditor.textContent;
            if (isWasmReady && editorModule) {
                try {
                    const json = editorModule.ccall('editor_parse_markdown', 'string', ['string'], [content]);
                    downloadFile('document.json', json || JSON.stringify({content}));
                    return;
                } catch (error) {
                    console.warn('WASM JSON export failed:', error);
                }
            }
            
            // Fallback JSON export
            const jsonData = {
                content: content,
                timestamp: new Date().toISOString(),
                version: "1.0"
            };
            downloadFile('document.json', JSON.stringify(jsonData, null, 2));
        }

        function exportHTML() {
            const content = hybridEditor.textContent;
            const html = renderMarkdown(content);
            const fullHtml = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
               max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        h1, h2, h3, h4, h5, h6 { margin-top: 2em; margin-bottom: 0.5em; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
        th { background: #f5f5f5; }
        mark { background: #ffd93d; }
    </style>
</head>
<body>
${html}
</body>
</html>`;
            downloadFile('document.html', fullHtml);
        }

        function importFile() {
            document.getElementById('fileInput').click();
        }
        
        // Test function to force render all lines
        async function testRenderAll() {
            console.log('=== TEST RENDER ALL ===');
            console.log('WASM ready:', isWasmReady);
            console.log('editorModule:', !!editorModule);
            console.log('Lines count:', editorLines.length);
            
            currentLineIndex = -1; // No current line
            
            for (let i = 0; i < editorLines.length; i++) {
                console.log(`Testing render line ${i}: "${editorLines[i].textContent}"`);
                await renderLine(i);
                console.log(`Line ${i} rendered`);
            }
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        // Initialize hybrid editor
        function initializeHybridEditor() {
            console.log('Initializing hybrid editor...');
            
            // Set up editor events
            hybridEditor.addEventListener('input', updateHybridPreview);
            hybridEditor.addEventListener('keyup', updateCursorPosition);
            hybridEditor.addEventListener('click', updateCursorPosition);
            hybridEditor.addEventListener('scroll', syncScroll);
            
            // Initial render
            updateHybridPreview();
            updateCursorPosition();
        }
        
        // Update cursor position and determine current line
        function updateCursorPosition() {
            const cursorPos = hybridEditor.selectionStart;
            const text = hybridEditor.value;
            
            // Count lines up to cursor position
            let lineNumber = 0;
            for (let i = 0; i < cursorPos; i++) {
                if (text[i] === '\n') {
                    lineNumber++;
                }
            }
            
            if (lineNumber !== currentCursorLine) {
                currentCursorLine = lineNumber;
                console.log('Cursor moved to line:', currentCursorLine);
                updateHybridPreview();
            }
        }
        
        // Sync scroll between editor and preview
        function syncScroll() {
            const scrollPercent = hybridEditor.scrollTop / (hybridEditor.scrollHeight - hybridEditor.clientHeight);
            hybridPreview.scrollTop = scrollPercent * (hybridPreview.scrollHeight - hybridPreview.clientHeight);
        }
        
        // Render a specific line to HTML
        async function renderLine(lineIndex) {
            if (!editorLines[lineIndex] || lineIndex === currentLineIndex) {
                console.log(`Skipping render line ${lineIndex}: not exists or current`);
                return;
            }
            
            const line = editorLines[lineIndex];
            
            // Use stored original text (with markdown) or current text
            const markdownText = (line.dataset.originalText || line.textContent || '').trim();
            
            console.log(`Rendering line ${lineIndex}: "${markdownText}"`);
            
            if (markdownText === '') {
                line.innerHTML = '&nbsp;'; // Non-breaking space for empty lines
                return;
            }
            
            // Check cache first
            if (cachedRenderedLines[lineIndex] && cachedRenderedLines[lineIndex].markdown === markdownText) {
                console.log(`Using cached render for line ${lineIndex}`);
                line.innerHTML = cachedRenderedLines[lineIndex].html;
                line.setAttribute('contenteditable', 'false');
                return;
            }
            
            try {
                const renderedHtml = await renderMarkdown(markdownText);
                
                // Remove outer paragraph tags if present for inline rendering
                const cleanHtml = renderedHtml.replace(/^<p>(.*)<\/p>$/s, '$1');
                
                // Create a wrapper to show rendered content with overlay editing
                line.innerHTML = `<div class="rendered-content">${cleanHtml}</div><div class="edit-overlay" style="display:none;">${markdownText}</div>`;
                line.setAttribute('data-rendered', 'true');
                
                // Cache the result
                cachedRenderedLines[lineIndex] = {
                    markdown: markdownText,
                    html: cleanHtml
                };
                
                console.log(`‚úÖ Rendered line ${lineIndex}: "${markdownText}" -> "${cleanHtml}"`);
            } catch (error) {
                console.warn('Error rendering line:', error);
                line.innerHTML = markdownText; // Fallback to plain text
            }
        }
        
        // Setup event listeners
        function setupEventListeners() {
            // Handle focus changes between lines
            editorLines.forEach((line, index) => {
                line.addEventListener('focus', async (e) => {
                    console.log(`Line ${index} got focus`);
                    
                    // Render the previously current line first
                    const oldIndex = currentLineIndex;
                    if (oldIndex !== index && oldIndex >= 0 && editorLines[oldIndex]) {
                        console.log(`Rendering previous line ${oldIndex}`);
                        await renderLine(oldIndex);
                    }
                    
                    // Switch current line to edit mode
                    currentLineIndex = index;
                    const markdownText = line.dataset.originalText || line.textContent || '';
                    
                    console.log(`Switching line ${index} to edit mode: "${markdownText}"`);
                    line.innerHTML = '';
                    line.textContent = markdownText;
                    line.removeAttribute('data-rendered');
                    
                    await updateCurrentLine();
                });
                
                line.addEventListener('blur', async (e) => {
                    console.log(`Line ${index} lost focus`);
                    // Store any changes
                    line.dataset.originalText = line.textContent;
                });
                
                line.addEventListener('input', (e) => {
                    // Store changes and clear cache
                    line.dataset.originalText = line.textContent;
                    delete cachedRenderedLines[index];
                });
            });
            
            // Handle keyboard navigation
            hybridEditor.addEventListener('keydown', async (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    document.execCommand('insertText', false, '    ');
                }
                
                if (e.key === 'Enter') {
                    e.preventDefault();
                    
                    const currentLine = editorLines[currentLineIndex];
                    
                    // Create new line
                    const newLine = document.createElement('div');
                    newLine.className = 'editor-line';
                    newLine.textContent = '';
                    newLine.setAttribute('contenteditable', 'true');
                    newLine.setAttribute('tabindex', '0');
                    
                    // Insert after current line
                    if (currentLine.nextElementSibling) {
                        hybridEditor.insertBefore(newLine, currentLine.nextElementSibling);
                    } else {
                        hybridEditor.appendChild(newLine);
                    }
                    
                    // Update line indices and event listeners
                    updateLineIndices();
                    setupEventListeners(); // Re-setup for new line
                    
                    // Move to new line
                    newLine.focus();
                }
                
                if (e.key === 'ArrowUp' && currentLineIndex > 0) {
                    e.preventDefault();
                    editorLines[currentLineIndex - 1].focus();
                }
                
                if (e.key === 'ArrowDown' && currentLineIndex < editorLines.length - 1) {
                    e.preventDefault();
                    editorLines[currentLineIndex + 1].focus();
                }
            });
            
            // Handle clicks outside editor to render all lines
            document.addEventListener('click', async (e) => {
                if (!hybridEditor.contains(e.target)) {
                    console.log('Clicked outside editor, rendering all lines');
                    currentLineIndex = -1; // No current line
                    await renderAllNonCurrentLines();
                }
            });
        }
        
        // Update line indices after DOM changes
        function updateLineIndices() {
            const lines = hybridEditor.querySelectorAll('.editor-line');
            lines.forEach((line, index) => {
                line.dataset.line = index;
            });
            editorLines = Array.from(lines);
        }
        
        // Update editor lines array when content changes
        function updateEditorLines() {
            const currentContent = hybridEditor.textContent;
            const lines = currentContent.split('\n');
            
            // Update data-line attributes
            const lineElements = hybridEditor.querySelectorAll('.editor-line');
            
            // Ensure we have the right number of line elements
            while (lineElements.length < lines.length) {
                const newLine = document.createElement('div');
                newLine.className = 'editor-line';
                hybridEditor.appendChild(newLine);
            }
            
            // Remove excess line elements
            while (lineElements.length > lines.length) {
                hybridEditor.removeChild(lineElements[lineElements.length - 1]);
            }
            
            // Update line data attributes
            const updatedLines = hybridEditor.querySelectorAll('.editor-line');
            updatedLines.forEach((line, index) => {
                line.dataset.line = index;
            });
            
            editorLines = Array.from(updatedLines);
        }
        
        // File handling
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const lines = e.target.result.split('\n');
                    
                    // Clear editor
                    hybridEditor.innerHTML = '';
                    
                    // Add lines
                    lines.forEach((lineText, index) => {
                        const lineElement = document.createElement('div');
                        lineElement.className = 'editor-line';
                        lineElement.dataset.line = index;
                        lineElement.textContent = lineText;
                        hybridEditor.appendChild(lineElement);
                    });
                    
                    initializeHybridEditor();
                };
                reader.readAsText(file);
            }
        });
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            await initializeWasm();
            initializeHybridEditor();
            
            // Render all lines except the current one initially
            setTimeout(async () => {
                for (let i = 0; i < editorLines.length; i++) {
                    if (i !== currentLineIndex) {
                        await renderLine(i);
                    }
                }
            }, 500);
        });
    </script>
</body>
</html>